<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <link rel="stylesheet" href="bootstrap/bootstrap.min.css" />
    <link rel="stylesheet" href="app.css" />

    <link rel="stylesheet" href="Universalscada.WebApp.styles.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <HeadOutlet @rendermode="new InteractiveServerRenderMode(prerender: false)" />
    <script src="https://cdn.plot.ly/plotly-2.31.1.min.js"></script>
</head>
<script>
    // Blazor'dan gelen veriyi alan ve Plotly ile grafiği çizen fonksiyon
    // Universalscada.WebApp/Components/App.razor - <script> bloğu içinde

     // Universalscada.WebApp/Components/App.razor - <script> bloğu içinde

    function plotTrendChart(chartId, dataPoints, selectedData) {
        if (!dataPoints || dataPoints.length === 0) {
            console.log("Grafik çizmek için veri yok.");
            Plotly.purge(chartId);
            return;
        }

        // KRİTİK DÜZELTME: Tüm özellikler camelCase (küçük harfle başlayan) olarak erişilmelidir.
        const timestamps = dataPoints.map(p => p.timestamp);
        let values;
        let yaxisTitle;

        switch (selectedData) {
            case 'Temperature':
                // C# (Temperature) -> JS (temperature)
                values = dataPoints.map(p => p.temperature / 10.0);
                yaxisTitle = 'Sıcaklık (°C)';
                break;
            case 'WaterLevel':
                // C# (WaterLevel) -> JS (waterLevel)
                values = dataPoints.map(p => p.waterLevel);
                yaxisTitle = 'Su Seviyesi';
                break;
            case 'Rpm':
                // C# (Rpm) -> JS (rpm)
                values = dataPoints.map(p => p.rpm);
                yaxisTitle = 'Devir (Rpm)';
                break;
            default:
                console.error("Geçersiz veri tipi.");
                return;
        }

        // TANI: Değerlerin gerçekten gelip gelmediğini kontrol eder.
        console.log(`Plotly çizim verisi kontrolü: Times (${timestamps.length} adet), Values (${values.length} adet)`);

        if (values.every(v => v === undefined || v === null)) {
             console.error("HATA: Değer dizisi boş veya tanımsız. JSON serileştirme hatası devam ediyor.");
             Plotly.purge(chartId);
             return;
        }


        const trace = {
            x: timestamps,
            y: values,
            mode: 'lines',
            type: 'scatter',
            name: selectedData
        };

        const layout = {
            title: `Trend Analizi: ${yaxisTitle} - Makine ${dataPoints[0].machineId}`,
            xaxis: {
                title: 'Zaman Damgası',
                type: 'date'
            },
            yaxis: {
                title: yaxisTitle
            }
        };

        Plotly.newPlot(chartId, [trace], layout, { responsive: true });
    }
</script>
<script>
   

    // Blazor'dan gelen ÜÇ SERİLİ veriyi alan ve Plotly ile grafiği çizen fonksiyon
    function plotTrendChart1(chartId, dataPoints, title) {
        if (!dataPoints || dataPoints.length === 0) {
            console.log("Grafik çizmek için veri yok.");
            Plotly.purge(chartId);
            return;
        }
         const timestamps = dataPoints.map(p => p.timestamp);
    
        // 1. Veri Hazırlama: TimestampOADate'i Date objesine çeviriyoruz.
        const xTime = timestamps;
        const yTemp = dataPoints.map(d => d.temperature);
        const yRpm = dataPoints.map(d => d.rpm);
        const yWater = dataPoints.map(d => d.waterLevel);

        // 2. Grafik Serileri (Traces)
        const traceTemp = {
            x: xTime,
            y: yTemp,
            name: 'Sıcaklık (°C)',
            type: 'scatter',
            mode: 'lines',
            line: { color: 'red' },
            yaxis: 'y1'
        };

        const traceRpm = {
            x: xTime,
            y: yRpm,
            name: 'Devir (RPM)',
            type: 'scatter',
            mode: 'lines',
            line: { color: 'blue' },
            yaxis: 'y2'
        };

        const traceWater = {
            x: xTime,
            y: yWater,
            name: 'Su Seviyesi',
            type: 'scatter',
            mode: 'lines',
            line: { color: 'green' },
            yaxis: 'y3'
        };

        // 3. Grafik Düzeni (Layout)
        const layout = {
            title: title || 'Canlı Proses Trend Grafiği',
            xaxis: {
                title: 'Zaman Damgası',
                type: 'timestamps', // Artık Plotly'ye Date objeleri gönderdiğimiz için bu doğru çalışacaktır.
                tickformat: '%Y-%m-%d\n%H:%M:%S' // Zaman formatını göster
            },
            yaxis: {
                title: 'Sıcaklık (°C)',
                showgrid: true,
                zeroline: true,
                side: 'left',
                automargin: true,
            },
            yaxis2: {
                title: 'Devir (RPM)',
                overlaying: 'y',
                side: 'right',
                showgrid: false,
                zeroline: false,
                automargin: true,
                position: 0.98, // Devir ekseni pozisyonu (sağdan 2%)
            },
            yaxis3: {
                title: 'Su Seviyesi',
                overlaying: 'y',
                side: 'right',
                position: 0.90, // Su seviyesi ekseni pozisyonu (sağdan 10%)
                showgrid: false,
                zeroline: false,
                automargin: true,
            },
            margin: { r: 0, b: 0 } // Sağ ve alt kenar boşluklarını artır
        };

        Plotly.newPlot(chartId, [traceTemp, traceRpm, traceWater], layout, { responsive: true });
    }
        
    function plotDashboardCharts(hourlyOeeData, hourlyConsumptionData, topAlarmsData) {
        if (!Plotly) {
            console.error("Plotly kütüphanesi yüklenmedi.");
return;
        }

        const isMobile = window.innerWidth <= 768;

        // 1. OEE Grafiği - AYARLI
        const plotOee = () => {
const containerId = 'oeeChartContainer';
            const data = hourlyOeeData.map(d => ({ hour: d.saat, oee: d.averageOEE }));
            if (data.length === 0) return Plotly.purge(containerId);
const trace = {
                x: data.map(d => `${d.hour}:00`),
                y: data.map(d => d.oee),
                type: 'bar',
marker: { color: 'rgba(46, 204, 113, 0.8)' },
                name: 'Ortalama OEE (%)'
            };
            
            // YENİ: Mobil ve Masaüstü için ayrı ayarlar
            const layout = {
                // Mobilde etiket açısını (tickangle) kaldır, masaüstünde kullan (45)
xaxis: { title: 'Saat', tickangle: isMobile ? 0 : 45, automargin: true },
                yaxis: { title: 'OEE (%)', range: [0, 100], automargin: true },
                // Mobilde (175px) alt boşluk 40, Masaüstünde (300px) eğik etiket için 70
                margin: { t: 30, b: isMobile ? 40 : 70, l: 40, r: 10 },
                // YENİ: CSS ile senkronize yükseklik
height: isMobile ? 160 : 250 
            };
            
            // YENİ: Mobilde 'responsive: false' (titremeyi durdurur), 
            // Masaüstünde 'responsive: true' (yeniden boyutlandırmaya izin verir).
Plotly.newPlot(containerId, [trace], layout, { displayModeBar: false, responsive: !isMobile });
        };

        // 2. Tüketim Grafikleri - AYARLI
const plotConsumption = (containerId, consumptionKey, title, unit, color) => {
const data = hourlyConsumptionData;
            if (data.length === 0) return Plotly.purge(containerId);
const values = data.map(d => d[consumptionKey]);
            const trace = {
                x: data.map(d => `${d.hour}:00`),
                y: values,
                type: 'bar',
marker: { color: color },
                name: title
            };
            const layout = {
                title: title,
                // Mobilde etiket açısını kaldır, masaüstünde kullan
                xaxis: { title: 'Saat', tickangle: isMobile ? 0 : 45, automargin: true },
                yaxis: { title: unit, automargin: true },
                margin: { t: 30, b: isMobile ? 40 : 70, l: 40, r: 10 },
                // YENİ: CSS ile senkronize yükseklik
height: isMobile ? 160 : 250 
            };
            // YENİ: Mobilde 'responsive: false'
Plotly.newPlot(containerId, [trace], layout, { displayModeBar: false, responsive: !isMobile });
        };

        // 3. En Sık Alarmlar Grafiği - AYARLI
const plotTopAlarms = () => {
const containerId = 'topAlarmsChartContainer';
            const data = topAlarmsData.sort((a, b) => a.count - b.count).slice(-5);
            if (data.length === 0) return Plotly.purge(containerId);
const trace = {
                x: data.map(d => d.count),
                y: data.map(d => d.alarmText.length > 20 ? d.alarmText.substring(0, 17) + '...' : d.alarmText),
                type: 'bar',
orientation: 'h',
                marker: { color: 'rgba(231, 76, 60, 0.8)' },
                name: 'Tekrar Sayısı'
            };
const layout = {
                xaxis: { title: 'Tekrar Sayısı', automargin: true },
                yaxis: { automargin: true },
                // Mobilde (175px) 'automargin' sol boşluğu kendi ayarlar,
                // Masaüstünde (300px) alarm metni için 'l: 150' kullanırız.
                margin: { t: 30, b: 40, l: isMobile ? 10 : 150, r: 10 },
                // YENİ: CSS ile senkronize yükseklik
height: isMobile ? 160 : 250 
            };
            // YENİ: Mobilde 'responsive: false'
Plotly.newPlot(containerId, [trace], layout, { displayModeBar: false, responsive: !isMobile });
        };

        // Tüm grafikleri çağır
plotOee();
        plotConsumption('electricChartContainer', 'toplamElektrik', '', 'kWh', '#3498db');
plotConsumption('waterChartContainer', 'toplamSu', '', 'Litre', '#2c3e50');
        plotConsumption('steamChartContainer', 'toplamBuhar', '', 'kg', '#9b59b6');
        plotTopAlarms();
}
       function drawPieChart(elementId, chartData) {
        if (!chartData || chartData.length === 0) {
            Plotly.purge(elementId);
            return;
        }

        const labels = chartData.map(d => d.label);
        const values = chartData.map(d => d.value);
        const colors = chartData.map(d => d.color);

        const data = [{
            values: values,
            labels: labels,
            type: 'pie',
            marker: {
                colors: colors
            },
            hoverinfo: 'label+percent+text',
            text: values.map(v => {
                // Saniyeyi hh:mm:ss formatına çevir
                const hours = Math.floor(v / 3600);
                const minutes = Math.floor((v % 3600) / 60);
                const seconds = Math.floor(v % 60);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }),
            textinfo: 'percent',
            hole: .4
        }];

        const layout = {
            height: 300,
            showlegend: true,
            margin: { t: 10, b: 10, l: 10, r: 10 }
        };

        Plotly.newPlot(elementId, data, layout, { responsive: true, displayModeBar: false });
    }

    // Production Detail - Zaman Çizgisi/Sıcaklık Grafiği
    function drawTimelineChart(elementId, chartData) {
        if (!chartData || chartData.length === 0) {
            Plotly.purge(elementId);
            return;
        }

        // X ekseninde Adım Numarası ve Açıklaması
        const steps = chartData.map(d => `Adım ${d.stepNumber} - ${d.description}`);
        // Y ekseninde Sıcaklık
        const temperatures = chartData.map(d => d.temperature);

        const trace = {
            x: steps,
            y: temperatures,
            mode: 'lines+markers',
            type: 'scatter',
            name: 'Sıcaklık (°C)',
            line: { color: '#e74c3c' } // Kırmızımsı renk
        };

        const layout = {
            title: 'Adım Sıcaklık Trendi',
            xaxis: {
                title: 'Reçete Adımı',
                automargin: true,
                tickangle: 45 // X ekseni etiketlerini eğerek okunabilirliği artırır
            },
            yaxis: {
                title: 'Sıcaklık (°C)'
            },
            margin: { t: 40, b: 120, l: 40, r: 20 }
        };

        Plotly.newPlot(elementId, [trace], layout, { responsive: true });
    }
    // 1. Base64 string'i Blob nesnesine dönüştüren yardımcı fonksiyon
    window.base64ToBlob = function (base64) {
        const binary = atob(base64);
        const array = [];
        for (let i = 0; i < binary.length; i++) {
            array.push(binary.charCodeAt(i));
        }
        // XLSX dosyası için doğru MIME tipi
        return new Blob([new Uint8Array(array)], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    };

    // 2. C# kodundan çağrılan ana indirme fonksiyonu
    window.saveAsFile = function (filename, bytesBase64) {
        const data = base64ToBlob(bytesBase64);

        // Bir URL oluştur
        const url = URL.createObjectURL(data);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;

        // İndirme işlemini tetikle
        document.body.appendChild(link);
        link.click();

        // Belleği temizle
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    };
</script>

<body>
    @* Sadece bir <Routes /> olmalı ve CascadingAuthenticationState'in içinde kalmalı *@
    <CascadingAuthenticationState>
        <Routes @rendermode="new InteractiveServerRenderMode(prerender: false)" />
    </CascadingAuthenticationState>
    
    <script src="_framework/blazor.web.js"></script>
</body>
</html>
